use heck::{ToLowerCamelCase, ToUpperCamelCase};
use rapace_schema::{MethodDetail, ServiceDetail, TypeDetail};

use crate::render::{fq_name, hex_u64};

pub fn generate_method_ids(methods: &[MethodDetail]) -> String {
    let mut items = methods
        .iter()
        .map(|m| (fq_name(m), crate::method_id(m)))
        .collect::<Vec<_>>();
    items.sort_by(|a, b| a.0.cmp(&b.0));

    let mut out = String::new();
    out.push_str("// Code generated by rapace-codegen. DO NOT EDIT.\n\n");
    out.push_str("import java.util.Map;\n\n");
    out.push_str("public final class RapaceMethodId {\n");
    out.push_str("    private RapaceMethodId() {}\n\n");
    out.push_str("    public static final Map<String, Long> BY_NAME = Map.ofEntries(\n");
    for (i, (name, id)) in items.iter().enumerate() {
        let comma = if i + 1 == items.len() { "" } else { "," };
        out.push_str(&format!(
            "        Map.entry(\"{name}\", {hex}L){comma}\n",
            hex = hex_u64(*id)
        ));
    }
    out.push_str("    );\n");
    out.push_str("}\n");
    out
}

/// Generate a complete Java file for a service.
pub fn generate_service(service: &ServiceDetail) -> String {
    let mut out = String::new();
    out.push_str("// Code generated by rapace-codegen. DO NOT EDIT.\n\n");
    out.push_str("import java.util.concurrent.CompletableFuture;\n\n");

    let service_name = service.name.to_upper_camel_case();

    // Generate method ID constants
    out.push_str(&format!("public final class {service_name}MethodId {{\n"));
    out.push_str(&format!("    private {service_name}MethodId() {{}}\n\n"));
    for method in &service.methods {
        let const_name = method.method_name.to_upper_camel_case();
        let id = crate::method_id(method);
        out.push_str(&format!(
            "    public static final long {} = {}L;\n",
            const_name.to_uppercase(),
            hex_u64(id)
        ));
    }
    out.push_str("}\n\n");

    // Generate client interface
    out.push_str(&generate_client_interface(service));

    // Generate server handler interface
    out.push_str(&generate_server_handler(service));

    out
}

fn generate_client_interface(service: &ServiceDetail) -> String {
    let mut out = String::new();
    let service_name = service.name.to_upper_camel_case();

    if let Some(doc) = &service.doc {
        out.push_str(&format!("/** {doc} */\n"));
    }
    out.push_str(&format!("public interface {service_name}Client {{\n"));

    for method in &service.methods {
        let method_name = method.method_name.to_lower_camel_case();
        let args = method
            .args
            .iter()
            .map(|a| {
                format!(
                    "{} {}",
                    java_type(&a.type_info),
                    a.name.to_lower_camel_case()
                )
            })
            .collect::<Vec<_>>()
            .join(", ");
        let ret_ty = java_type(&method.return_type);

        if let Some(doc) = &method.doc {
            out.push_str(&format!("    /** {doc} */\n"));
        }
        out.push_str(&format!(
            "    CompletableFuture<{ret_ty}> {method_name}({args});\n"
        ));
    }

    out.push_str("}\n\n");
    out
}

fn generate_server_handler(service: &ServiceDetail) -> String {
    let mut out = String::new();
    let service_name = service.name.to_upper_camel_case();

    out.push_str(&format!(
        "/** Server handler interface for {service_name}. */\n"
    ));
    out.push_str(&format!("public interface {service_name}Handler {{\n"));

    for method in &service.methods {
        let method_name = method.method_name.to_lower_camel_case();
        let args = method
            .args
            .iter()
            .map(|a| {
                format!(
                    "{} {}",
                    java_type(&a.type_info),
                    a.name.to_lower_camel_case()
                )
            })
            .collect::<Vec<_>>()
            .join(", ");
        let ret_ty = java_type(&method.return_type);

        out.push_str(&format!(
            "    CompletableFuture<{ret_ty}> {method_name}({args});\n"
        ));
    }

    out.push_str("}\n\n");

    // Generate dispatcher class
    out.push_str(&format!("/** Dispatcher for {service_name} service. */\n"));
    out.push_str(&format!("public final class {service_name}Dispatcher {{\n"));
    out.push_str(&format!(
        "    private final {service_name}Handler handler;\n\n"
    ));
    out.push_str(&format!(
        "    public {service_name}Dispatcher({service_name}Handler handler) {{\n"
    ));
    out.push_str("        this.handler = handler;\n");
    out.push_str("    }\n\n");

    out.push_str(
        "    public CompletableFuture<byte[]> dispatch(long methodId, byte[] payload) {\n",
    );
    out.push_str("        switch ((int) methodId) {\n");

    for method in &service.methods {
        let method_name = method.method_name.to_lower_camel_case();
        let id = crate::method_id(method);
        // Use int cast since Java switch doesn't work well with long
        out.push_str(&format!("            case (int) {}L:\n", hex_u64(id)));
        out.push_str("                // TODO: decode payload, call handler, encode response\n");
        out.push_str(&format!(
            "                throw new UnsupportedOperationException(\"{method_name}: not yet implemented\");\n"
        ));
    }

    out.push_str("            default:\n");
    out.push_str(
        "                throw new IllegalArgumentException(\"Unknown method ID: \" + methodId);\n",
    );
    out.push_str("        }\n");
    out.push_str("    }\n");
    out.push_str("}\n");

    out
}

fn java_type(ty: &TypeDetail) -> String {
    match ty {
        TypeDetail::Bool => "Boolean".into(),
        TypeDetail::U8 | TypeDetail::I8 => "Byte".into(),
        TypeDetail::U16 | TypeDetail::I16 => "Short".into(),
        TypeDetail::U32 | TypeDetail::I32 => "Integer".into(),
        TypeDetail::U64 | TypeDetail::I64 => "Long".into(),
        TypeDetail::U128 | TypeDetail::I128 => "java.math.BigInteger".into(),
        TypeDetail::F32 => "Float".into(),
        TypeDetail::F64 => "Double".into(),
        TypeDetail::Char => "Character".into(),
        TypeDetail::String => "String".into(),
        TypeDetail::Unit => "Void".into(),
        TypeDetail::Bytes => "byte[]".into(),
        TypeDetail::List(inner) => format!("java.util.List<{}>", java_type(inner)),
        TypeDetail::Option(inner) => format!("java.util.Optional<{}>", java_type(inner)),
        TypeDetail::Array { element, .. } => format!("{}[]", java_type(element)),
        TypeDetail::Map { key, value } => {
            format!("java.util.Map<{}, {}>", java_type(key), java_type(value))
        }
        TypeDetail::Set(inner) => format!("java.util.Set<{}>", java_type(inner)),
        TypeDetail::Tuple(items) => {
            // Java doesn't have tuples; would need a record or class
            match items.len() {
                2 => format!(
                    "java.util.Map.Entry<{}, {}>",
                    java_type(&items[0]),
                    java_type(&items[1])
                ),
                _ => "Object[]".into(),
            }
        }
        TypeDetail::Stream(inner) => format!("java.util.stream.Stream<{}>", java_type(inner)),
        TypeDetail::Struct { .. } => "Object".into(), // Would need proper class generation
        TypeDetail::Enum { .. } => "Object".into(),   // Would need proper enum generation
    }
}
