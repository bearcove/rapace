use heck::{ToSnakeCase, ToUpperCamelCase};
use rapace_schema::{MethodDetail, ServiceDetail, TypeDetail};

use crate::render::{fq_name, hex_u64};

pub fn generate_method_ids(methods: &[MethodDetail]) -> String {
    let mut items = methods
        .iter()
        .map(|m| (fq_name(m), crate::method_id(m)))
        .collect::<Vec<_>>();
    items.sort_by(|a, b| a.0.cmp(&b.0));

    let mut out = String::new();
    out.push_str("// Code generated by rapace-codegen. DO NOT EDIT.\n\n");
    out.push_str("package rapace\n\n");
    out.push_str("var MethodID = map[string]uint64{\n");
    for (name, id) in items {
        out.push_str(&format!("    \"{name}\": {hex},\n", hex = hex_u64(id)));
    }
    out.push_str("}\n");
    out
}

/// Generate a complete Go file for a service.
pub fn generate_service(service: &ServiceDetail) -> String {
    let mut out = String::new();
    out.push_str("// Code generated by rapace-codegen. DO NOT EDIT.\n\n");
    out.push_str("package rapace\n\n");
    out.push_str("import \"context\"\n\n");

    let service_name = service.name.to_upper_camel_case();

    // Generate method ID constants
    out.push_str("// Method IDs\n");
    out.push_str("const (\n");
    for method in &service.methods {
        let method_name = method.method_name.to_upper_camel_case();
        let id = crate::method_id(method);
        out.push_str(&format!(
            "\t{service_name}Method{method_name} uint64 = {}\n",
            hex_u64(id)
        ));
    }
    out.push_str(")\n\n");

    // Generate client interface
    out.push_str(&generate_client_interface(service));

    // Generate server handler interface
    out.push_str(&generate_server_handler(service));

    out
}

fn generate_client_interface(service: &ServiceDetail) -> String {
    let mut out = String::new();
    let service_name = service.name.to_upper_camel_case();

    if let Some(doc) = &service.doc {
        out.push_str(&format!("// {service_name}Client - {doc}\n"));
    } else {
        out.push_str(&format!(
            "// {service_name}Client provides client methods for the service.\n"
        ));
    }
    out.push_str(&format!("type {service_name}Client interface {{\n"));

    for method in &service.methods {
        let method_name = method.method_name.to_upper_camel_case();
        let args = method
            .args
            .iter()
            .map(|a| format!("{} {}", a.name.to_snake_case(), go_type(&a.type_info)))
            .collect::<Vec<_>>()
            .join(", ");
        let ret_ty = go_type(&method.return_type);

        if let Some(doc) = &method.doc {
            out.push_str(&format!("\t// {method_name} - {doc}\n"));
        }
        if ret_ty == "()" {
            out.push_str(&format!(
                "\t{method_name}(ctx context.Context, {args}) error\n"
            ));
        } else {
            out.push_str(&format!(
                "\t{method_name}(ctx context.Context, {args}) ({ret_ty}, error)\n"
            ));
        }
    }

    out.push_str("}\n\n");
    out
}

fn generate_server_handler(service: &ServiceDetail) -> String {
    let mut out = String::new();
    let service_name = service.name.to_upper_camel_case();

    out.push_str(&format!(
        "// {service_name}Handler handles server-side method calls.\n"
    ));
    out.push_str(&format!("type {service_name}Handler interface {{\n"));

    for method in &service.methods {
        let method_name = method.method_name.to_upper_camel_case();
        let args = method
            .args
            .iter()
            .map(|a| format!("{} {}", a.name.to_snake_case(), go_type(&a.type_info)))
            .collect::<Vec<_>>()
            .join(", ");
        let ret_ty = go_type(&method.return_type);

        if ret_ty == "()" {
            out.push_str(&format!(
                "\t{method_name}(ctx context.Context, {args}) error\n"
            ));
        } else {
            out.push_str(&format!(
                "\t{method_name}(ctx context.Context, {args}) ({ret_ty}, error)\n"
            ));
        }
    }

    out.push_str("}\n\n");

    // Generate dispatcher function
    out.push_str(&format!(
        "// New{service_name}Dispatcher creates a dispatcher for the service.\n"
    ));
    out.push_str(&format!(
        "func New{service_name}Dispatcher(handler {service_name}Handler) func(ctx context.Context, methodID uint64, payload []byte) ([]byte, error) {{\n"
    ));
    out.push_str(
        "\treturn func(ctx context.Context, methodID uint64, payload []byte) ([]byte, error) {\n",
    );
    out.push_str("\t\tswitch methodID {\n");

    for method in &service.methods {
        let method_name = method.method_name.to_upper_camel_case();
        let id = crate::method_id(method);
        out.push_str(&format!("\t\tcase {}:\n", hex_u64(id)));
        out.push_str("\t\t\t// TODO: decode payload, call handler, encode response\n");
        out.push_str(&format!(
            "\t\t\tpanic(\"{method_name}: not yet implemented\")\n"
        ));
    }

    out.push_str("\t\tdefault:\n");
    out.push_str("\t\t\treturn nil, fmt.Errorf(\"unknown method ID: %d\", methodID)\n");
    out.push_str("\t\t}\n");
    out.push_str("\t}\n");
    out.push_str("}\n");

    out
}

fn go_type(ty: &TypeDetail) -> String {
    match ty {
        TypeDetail::Bool => "bool".into(),
        TypeDetail::U8 => "uint8".into(),
        TypeDetail::U16 => "uint16".into(),
        TypeDetail::U32 => "uint32".into(),
        TypeDetail::U64 => "uint64".into(),
        TypeDetail::U128 => "[16]byte".into(), // Go has no native uint128
        TypeDetail::I8 => "int8".into(),
        TypeDetail::I16 => "int16".into(),
        TypeDetail::I32 => "int32".into(),
        TypeDetail::I64 => "int64".into(),
        TypeDetail::I128 => "[16]byte".into(), // Go has no native int128
        TypeDetail::F32 => "float32".into(),
        TypeDetail::F64 => "float64".into(),
        TypeDetail::Char => "rune".into(),
        TypeDetail::String => "string".into(),
        TypeDetail::Unit => "()".into(),
        TypeDetail::Bytes => "[]byte".into(),
        TypeDetail::List(inner) => format!("[]{}", go_type(inner)),
        TypeDetail::Option(inner) => format!("*{}", go_type(inner)),
        TypeDetail::Array { element, len } => format!("[{}]{}", len, go_type(element)),
        TypeDetail::Map { key, value } => format!("map[{}]{}", go_type(key), go_type(value)),
        TypeDetail::Set(inner) => format!("map[{}]struct{{}}", go_type(inner)),
        TypeDetail::Tuple(items) => {
            // Go doesn't have tuples; use a struct
            let inner = items
                .iter()
                .enumerate()
                .map(|(i, t)| format!("F{} {}", i, go_type(t)))
                .collect::<Vec<_>>()
                .join("; ");
            format!("struct {{ {inner} }}")
        }
        TypeDetail::Stream(inner) => format!("<-chan {}", go_type(inner)),
        TypeDetail::Struct { fields } => {
            let inner = fields
                .iter()
                .map(|f| format!("{} {}", f.name.to_upper_camel_case(), go_type(&f.type_info)))
                .collect::<Vec<_>>()
                .join("; ");
            format!("struct {{ {inner} }}")
        }
        TypeDetail::Enum { .. } => "interface{}".into(), // Would need proper type generation
    }
}
